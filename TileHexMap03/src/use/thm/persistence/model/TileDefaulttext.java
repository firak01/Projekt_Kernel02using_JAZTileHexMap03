package use.thm.persistence.model;

import java.io.Serializable;

import javax.persistence.Access;
import javax.persistence.AccessType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.Table;
import javax.persistence.TableGenerator;

import basic.persistence.model.IFieldDescription;
import basic.persistence.model.IKeyEnum;
import basic.persistence.model.IOptimisticLocking;
import basic.zBasic.persistence.interfaces.enums.AbstractValue;
import basic.zBasic.persistence.interfaces.enums.IKeyProviderZZZ;
import basic.zBasic.persistence.interfaces.enums.IKeyValueZZZ;
import basic.zBasic.persistence.interfaces.enums.KeyEnum;

//Merke: Neue Entities immer in HibernateContextProviderSingletonTHM hinzufügen. In hibernate.cfg.xml reicht nicht.

@Entity
@Access(AccessType.PROPERTY) ///20171019: damit soll dann enum eingebunden werden, automatisch...
//@Inheritance(strategy =  InheritanceType.JOINED )//ZIEL: Nur bestimmte Entiteis in einer eigenen Klasse //InheritanceType.TABEL_PER_CLASS) //Ziel: Jedes Entity der Vererbungshierarchie in einer eigenen Tabelle // InheritanceType.SINGLE_TABLE) //Hiermit werden alle Datensätze der Vererbungshierarchieklassen in einer Tabelle zusammengafasst und nur anhan ddes Discriminator Wertes unterschieden 
//Bei InheritanceType.TABLE_PER_CLASS gilt, es darf keinen Discriminator geben ... @DiscriminatorColumn(name="Disc", discriminatorType = DiscriminatorType.STRING) //Bei InheritanceType.SINGLE_TABLE) gilt: Voraussetzung für DiscriminatorValue in der AreaCell-Klasse. //Wird es wg. der Vererbung von HEXCell zu AreaType immer geben. Ohne Annotation ist das DTYPE und der wert ist gleich dem Klassennamen.
@Table(name="k_tile_defaulttext")
public class TileDefaulttext extends AbstractValue<TileDefaulttext>{ //implements Serializable, IOptimisticLocking{
	
	/**
	 * 
	 */
	private static final long serialVersionUID = 1L;

	//Variante 2: Realisierung eines Schlüssel über eine eindeutige ID, die per Generator erzeugt wird
	//@Id //hier notwendig für AccessType.FIELD
	private int iMyTestSequence;
	
	private String sTextDefault;
	
	
	//### Variante 2: Verwende auf dieser Ebene einen Generator, zum Erstellen einer ID
	 @Id	//hier notwendig für AccessType.PROPERTY			
	 @TableGenerator(name="lidGeneratorDefaulttext002", table="COMMON_FUER_IDGENERATOR_DEFAULTTEXT002",pkColumnName="nutzende_Klasse_als_String", pkColumnValue="SequenceTester",valueColumnName="naechster_id_wert",  initialValue=1, allocationSize=1)//@TableGenerator Name muss einzigartig im ganzen Projekt sein.
	 @GeneratedValue(strategy = GenerationType.TABLE, generator="lidGeneratorDefaulttext001")		 //Das Klappt mit Hibernate Session, aber nicht mit dem JPA EntityManager...
	 //Bei dieser Column Definition ist die Spalte nicht für @OneToMany mit @JoinTable zu gebrauchen @Column(name="TILE_ID_INCREMENTED", nullable=false, unique=true, columnDefinition="INTEGER NOT NULL UNIQUE  DEFAULT 1")
	 //Entferne also das unique...
	 @Column(name="DEFAULTTEXT_ID_INCREMENTED", nullable=false)
	 public int getId(){
		 return this.iMyTestSequence;
	 }
	 public void setId(int iLid){
		 this.iMyTestSequence = iLid;
	 }
     
	@Column(name="defaulttext", nullable=false)	 
	public String getDefaulttext(){
		return this.sTextDefault;
	}
	public void setDefaulttext(String s){
		this.sTextDefault = s;
	}
	
	
    private Long hiskeyId;

    /** */
    public enum TileDefaulttextValueEnum  implements IKeyProviderZZZ<Long> {

        /**
         * Präsenzstudium
         */
        @IFieldDescription(description = "Präsenzstudium") Praesenzstudium(1),

        /**
         * Fernstudium
         */
        @IFieldDescription(description = "Fernstudium") Fernstudium(2),

        /**
         * Praxissemester
         */
        @IFieldDescription(description = "Praxissemester") Praxissemester(3),

        /**
         * Präsenzstudium im Ausland
         */
        @IFieldDescription(description = "Präsenzstudium im Ausland") PraesenzstudiumImAusland(4),

        /**
         * Praxissemester Ausland
         */
        @IFieldDescription(description = "Praxissemester Ausland") PraxissemesterImAusland(5);

        private Long key;

        TileDefaulttextValueEnum(int key) {
            this.key = Long.valueOf(key);
        }

       
        @Override
        public Long getThiskey() {
            return key;
        }
    }


   // @Override
    public Class<TileDefaulttextValueEnum> getThiskeyEnumClass() {
        return TileDefaulttextValueEnum.class;
    }
 

    /* GENERATED_BEGIN */

    /**
     * Autogenerated Default-Constructor
     * cut&paste out of 'GENERATED'-Block to modify
     */
    public TileDefaulttext() {
       // super();
    }

    /**
     * Autogenerated Constructor to use if an already generated objGuid is to be used (e.g. from an EntityDto)
     * @param objGuid
     */
//    public TileDefaulttext(... objGuid.toString()) {
//   //     this();
//    //    setObjGuid(objGuid.toString());
//    }

    /**
     * @return hiskeyId
     */
  //  @Override
    public Long getThiskeyId() {
        return hiskeyId;
    }


    /**
     * @param newValue
     */
  //  @Override
    public void setThiskeyId(Long newValue) {
        this.hiskeyId = newValue;
    }


    private static final java.util.List<String> allAttributeNames = java.util.Arrays.asList(new String[]{"hiskeyId"});

    /**
     * {@inheritDoc}
     */
  //  @java.lang.Override
    public java.util.List<String> getAllAttributeNames() {
        return getAllAttributeNamesIntern();
    }

    /**
     * {@inheritDoc}
     */
//    @java.lang.Override
    protected java.util.List<String> getAllAttributeNamesIntern() {
   //TODO GOON: das holen 20171024     java.util.List<String> tmp = super.getAllAttributeNamesIntern();
     //   tmp.addAll(allAttributeNames);
   //     return tmp;
    	
    	return null;
    }
    /* GENERATED_END */
	
	
	
	
		
}//end class
