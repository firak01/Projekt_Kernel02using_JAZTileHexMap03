package use.thm.persistence.model;

import java.io.Serializable;

import javax.persistence.Access;
import javax.persistence.AccessType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Inheritance;
import javax.persistence.InheritanceType;
import javax.persistence.Table;
import javax.persistence.TableGenerator;
import javax.persistence.Transient;

import base.datatype.KeyEnum;
import basic.persistence.model.IFieldDescription;
import basic.persistence.model.IKeyEnum;
import basic.persistence.model.IOptimisticLocking;
import basic.zBasic.persistence.interfaces.enums.AbstractValue;
import basic.zBasic.persistence.interfaces.enums.IThiskeyProviderZZZ;
import basic.zBasic.persistence.interfaces.enums.IThiskeyValueZZZ;

/**
*  Variante - nicht vewendet - : Hier wird ein Enum - Klasse ausserhalb verwendet.
*  Das ist aber unschön. Verwendet wird statt dessen die Klasse TileDefaulttext. Dort ist eine interne Klasse mit einem Enum vorhanden.
*  So hält man das Entity und die Defaultwerte für die Initiierung zusammen.
*  
* @author Fritz Lindhauer
*
*/

//Merke: Neue Entities immer in HibernateContextProviderSingletonTHM hinzufügen. In hibernate.cfg.xml reicht nicht.


@Entity
@Access(AccessType.PROPERTY) ///20171019: damit soll dann enum eingebunden werden, automatisch...
//@Inheritance(strategy =  InheritanceType.JOINED )//ZIEL: Nur bestimmte Entiteis in einer eigenen Klasse //InheritanceType.TABEL_PER_CLASS) //Ziel: Jedes Entity der Vererbungshierarchie in einer eigenen Tabelle // InheritanceType.SINGLE_TABLE) //Hiermit werden alle Datensätze der Vererbungshierarchieklassen in einer Tabelle zusammengafasst und nur anhan ddes Discriminator Wertes unterschieden 
//Bei InheritanceType.TABLE_PER_CLASS gilt, es darf keinen Discriminator geben ... @DiscriminatorColumn(name="Disc", discriminatorType = DiscriminatorType.STRING) //Bei InheritanceType.SINGLE_TABLE) gilt: Voraussetzung für DiscriminatorValue in der AreaCell-Klasse. //Wird es wg. der Vererbung von HEXCell zu AreaType immer geben. Ohne Annotation ist das DTYPE und der wert ist gleich dem Klassennamen.
@Table(name="k_tile_defaulttext_value")
public class TileDefaulttextValue extends Key implements Serializable, IOptimisticLocking{ //AbstractValue<TileDefaulttextValue>{ //implements Serializable, IOptimisticLocking{
	private static final long serialVersionUID = 3656054848317395826L;

	//Variante 2: Realisierung eines Schlüssel über eine eindeutige ID, die per Generator erzeugt wird
	//@Id //hier notwendig für AccessType.FIELD
//	private int iMyTestSequence;
	
	private String sTextDefault;
	
	
	//### Variante 2: Verwende auf dieser Ebene einen Generator, zum Erstellen einer ID
	//ABER NICHT AUF DIESER EBENEN, DA SIE ERBT VON KEY.java
//	 @Id	//hier notwendig für AccessType.PROPERTY			
//	 @TableGenerator(name="lidGeneratorDefaulttext002", table="COMMON_FUER_IDGENERATOR_DEFAULTTEXT002",pkColumnName="nutzende_Klasse_als_String", pkColumnValue="SequenceTester",valueColumnName="naechster_id_wert",  initialValue=1, allocationSize=1)//@TableGenerator Name muss einzigartig im ganzen Projekt sein.
//	 @GeneratedValue(strategy = GenerationType.TABLE, generator="lidGeneratorDefaulttext002")		 //Das Klappt mit Hibernate Session, aber nicht mit dem JPA EntityManager...
//	 //Bei dieser Column Definition ist die Spalte nicht für @OneToMany mit @JoinTable zu gebrauchen @Column(name="TILE_ID_INCREMENTED", nullable=false, unique=true, columnDefinition="INTEGER NOT NULL UNIQUE  DEFAULT 1")
//	 //Entferne also das unique...
//	 @Column(name="DEFAULTTEXT_ID_INCREMENTED", nullable=false)
//	 public int getId(){
//		 return this.iMyTestSequence;
//	 }
//	 public void setId(int iLid){
//		 this.iMyTestSequence = iLid;
//	 }
     
	@Column(name="defaulttext", nullable=false)	 
	public String getDefaulttext(){
		return this.sTextDefault;
	}
	public void setDefaulttext(String s){
		this.sTextDefault = s;
	}
	
	
    private Long hiskeyId;

    /* GENERATED_BEGIN */

    /**
     * Autogenerated Default-Constructor
     * cut&paste out of 'GENERATED'-Block to modify
     */
    public TileDefaulttextValue() {
       super();
    	this.setKeyType("DEFAULTTEXTVALUE"); //TODO: Ggfs. DEFAULTTEXTVALUE auch in einer Enumeration aller möglichen Schlüsselwerte hinterlegen.
    }

    /**
     * Autogenerated Constructor to use if an already generated objGuid is to be used (e.g. from an EntityDto)
     * @param objGuid
     */
//    public TileDefaulttext(... objGuid.toString()) {
//   //     this();
//    //    setObjGuid(objGuid.toString());
//    }
    
   //### ABSTRACTE METHODEN
    @Transient
    public Class<TileDefaulttextType> getThiskeyEnumClass() {
        return TileDefaulttextType.class;
    }
 
   @Column(name="thiskey_id",  nullable=false, unique=true, columnDefinition="LONG NOT NULL UNIQUE  DEFAULT 1")
   @Override
    public Long getThiskey() {
        return hiskeyId;
    }
    @Override
    public void setThiskey(Long newValue) {
        this.hiskeyId = newValue;
    }


    private static final java.util.List<String> allAttributeNames = java.util.Arrays.asList(new String[]{});

    /**
     * {@inheritDoc}
     */
  //  @java.lang.Override
    @Transient
    public java.util.List<String> getAllAttributeNames() {
        return getAllAttributeNamesIntern();
    }

    /**
     * {@inheritDoc}
     */
//    @java.lang.Override
    @Transient
    protected java.util.List<String> getAllAttributeNamesIntern() {
    	java.util.List<String> tmp = super.getAllAttributeNamesIntern();
    	tmp.addAll(allAttributeNames);
        return tmp;
    }
    /* GENERATED_END */
	
	
	
	
		
}//end class
